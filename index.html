<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wall Projection AR</title>
    
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: monospace; }

        /* UI Overlay */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Top HUD */
        .hud-top {
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 15px;
            text-align: center;
            border-bottom: 2px solid #00ff00;
        }
        .status-big { font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        .status-detail { font-size: 12px; color: #ccc; }

        /* Center Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 2px; background: red;
            transform: translate(-50%, -50%);
        }
        #crosshair::after {
            content: ""; position: absolute; left: 9px; top: -9px;
            width: 2px; height: 20px; background: red;
        }

        /* The Measurement Line (Projected) */
        #projected-line {
            position: absolute;
            left: 10%; right: 10%;
            height: 4px;
            background: #ff00ff; /* Magenta Line */
            box-shadow: 0 0 10px #ff00ff;
            display: none; /* Hidden until valid */
        }
        #projected-label {
            position: absolute; right: 0; top: -25px;
            background: #ff00ff; color: white;
            padding: 2px 8px; font-size: 14px; font-weight: bold;
        }

        /* Slider Controls */
        .controls {
            pointer-events: auto;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            color: white;
        }
        input[type=range] { width: 100%; margin: 15px 0; }
        
        .warn { color: red; font-weight: bold; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="dist-status" class="status-big">SCANNING FLOOR...</div>
            <div id="tilt-status" class="status-detail">Tilt: 0° | Height: 0cm</div>
        </div>

        <div id="projected-line">
            <div id="projected-label">152 cm</div>
        </div>

        <div id="crosshair"></div>

        <div class="controls">
            <label>ADJUST TARGET HEIGHT</label>
            <input type="range" id="h-slider" min="50" max="200" value="152" oninput="updateTarget(this.value)">
            <div style="display:flex; justify-content:space-between;">
                <span>Target: <b id="slider-val">152</b> cm</span>
                <button onclick="lockDistance()">LOCK DISTANCE</button>
            </div>
        </div>
    </div>

    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;" vr-mode-ui="enabled: false">
        
        <a-marker preset="hiro" id="floor-marker">
            <a-plane rotation="-90 0 0" width="1" height="1" color="#00ff00" opacity="0.5"></a-plane>
            <a-box position="0 0.5 0" scale="1 1 1" material="color: lime; wireframe: true;"></a-box>
            
            <a-torus position="0 8.94 0" rotation="90 0 0" radius="0.5" radius-tubular="0.05" color="red"></a-torus>
        </a-marker>

        <a-entity camera></a-entity>
    </a-scene>

<script>
    // --- CONFIG ---
    const MARKER_SIZE_CM = 17.0; 
    const REQUIRED_DIST_CM = 200; // User must stand 2m away
    const VERTICAL_FOV = 60; // Approx FOV

    // --- STATE ---
    let cameraHeightCm = 150; // Will be auto-calibrated by marker
    let currentDistCm = 0;
    let targetHeightCm = 152;
    let isDistanceLocked = false;

    // --- ELEMENTS ---
    const marker = document.querySelector("#floor-marker");
    const cameraEl = document.querySelector("[camera]");
    const distStatus = document.getElementById("dist-status");
    const tiltStatus = document.getElementById("tilt-status");
    const projLine = document.getElementById("projected-line");
    const label = document.getElementById("projected-label");

    // --- MAIN LOOP ---
    setInterval(() => {
        // 1. GET SENSOR DATA
        // Note: We use camera rotation X for pitch (simpler than raw gyro)
        const pitchRad = cameraEl.object3D.rotation.x;
        const pitchDeg = (pitchRad * 180) / Math.PI;

        // 2. MARKER TRACKING (FIND FLOOR)
        if (marker.object3D.visible) {
            // Calculate distance to marker
            const dUnits = marker.object3D.position.distanceTo(cameraEl.object3D.position);
            currentDistCm = dUnits * MARKER_SIZE_CM;

            // Auto-calibrate Camera Height based on marker position
            // If marker is on floor, Camera Height = Distance * sin(Pitch) roughly
            // But easier: AR.js gives relative Y.
            // Let's rely on the explicit "2m" rule.
            
            if (!isDistanceLocked) {
                const diff = Math.abs(currentDistCm - REQUIRED_DIST_CM);
                if (diff < 15) {
                    distStatus.innerText = "DISTANCE GOOD (2.0m)";
                    distStatus.style.color = "#00ff00";
                    distStatus.classList.remove("warn");
                } else {
                    distStatus.innerText = `MOVE TO 2M (Current: ${(currentDistCm/100).toFixed(1)}m)`;
                    distStatus.style.color = "red";
                    distStatus.classList.add("warn");
                }
            }
        }

        // 3. PROJECTION MATH (The "Tilt Logic")
        // We want to draw a line on screen corresponding to 'targetHeightCm' on the wall.
        // Formula: y_screen = focal_length * tan(angle_to_target - camera_pitch)
        
        // A. Calculate Angle to Target Height
        // height_diff = target_height - camera_height
        // We assume camera height is approx 150cm (avg human) OR we derive it.
        // Let's assume user holds phone at eye level ~150cm.
        const heightDiff = targetHeightCm - 150; 
        
        // Angle alpha = arctan(height_diff / distance_to_wall)
        const alphaRad = Math.atan(heightDiff / REQUIRED_DIST_CM);

        // B. Calculate Screen Position
        // The angle relative to the center of the camera view
        const relativeAngle = alphaRad - pitchRad;

        // Convert to Screen Percentage (0% top, 100% bottom)
        // 50% is center. 
        // We map +/- FOV/2 to 0-100%
        const fovRad = (VERTICAL_FOV * Math.PI) / 180;
        const screenY = 0.5 - (Math.tan(relativeAngle) / (2 * Math.tan(fovRad/2)));
        
        // C. Update UI Line
        if (screenY > 0 && screenY < 1) {
            projLine.style.display = "block";
            projLine.style.top = (screenY * 100) + "%";
            
            // Update Text
            tiltStatus.innerText = `Tilt: ${pitchDeg.toFixed(1)}° (Compensated) | Dist: 2.0m`;
        } else {
            projLine.style.display = "none"; // Target is off-screen
        }

    }, 50);

    function updateTarget(val) {
        targetHeightCm = val;
        document.getElementById("slider-val").innerText = val;
        label.innerText = val + " cm";
    }

    function lockDistance() {
        isDistanceLocked = true;
        distStatus.innerText = "DISTANCE LOCKED (2.0m)";
        distStatus.style.color = "cyan";
        distStatus.classList.remove("warn");
    }

</script>
</body>
</html>